import { GoogleGenerativeAI } from '@google/generative-ai';
import { apiService } from './api';
impor      // Check if response has function calls
      let functionCalls: any[] = [];
      try {
        console.log('ğŸ” [EnhancedAI] Checking for function calls...');
        console.log('ğŸ” [EnhancedAI] Response type:', typeof response);
        console.log('ğŸ” [EnhancedAI] Response keys:', Object.keys(response));
        
        functionCalls = response.functionCalls() || [];
        console.log('ğŸ”§ [EnhancedAI] Function calls result:', functionCalls);
        console.log('ğŸ”§ [EnhancedAI] Function calls length:', functionCalls.length);
        
        // Log each function call structure in detail
        functionCalls.forEach((fc: any, idx: number) => {
          console.log(`\nğŸ” [EnhancedAI] === Function Call ${idx} ===`);
          console.log(`ğŸ” [EnhancedAI] Type:`, typeof fc);
          console.log(`ğŸ” [EnhancedAI] Keys:`, Object.keys(fc));
          console.log(`ğŸ” [EnhancedAI] name:`, fc.name);
          console.log(`ğŸ” [EnhancedAI] args:`, fc.args);
          console.log(`ğŸ” [EnhancedAI] parameters:`, fc.parameters);
          console.log(`ğŸ” [EnhancedAI] Full object:`, JSON.stringify(fc, null, 2));
        });
      } catch (e) {
        console.log('âš ï¸ [EnhancedAI] No function calls or error getting them:', e);
      }TION_SCHEMAS, FUNCTION_CALLING_SYSTEM_PROMPT, FunctionCallResult } from './aiFunction';
import { ListRequest, TaskRequest, ProjectWithLists } from '@/types';
import { toast } from '@/hooks/use-toast';

export interface AIMessage {
  id: string;
  content: string;
  type: 'user' | 'ai';
  timestamp: Date;
  functionCalls?: FunctionCall[];
  functionResults?: FunctionCallResult[];
}

export interface FunctionCall {
  name: string;
  parameters: any;
}

export class EnhancedAIService {
  private genAI: GoogleGenerativeAI | null = null;
  private model: any = null;
  private projectUid: string;
  private currentProjectData: ProjectWithLists | null = null;

  constructor(projectUid: string) {
    console.log('ğŸ—ï¸ [EnhancedAI] Constructor called with projectUid:', projectUid);
    this.projectUid = projectUid;
    this.initializeAI();
  }

  private async initializeAI() {
    console.log('ğŸš€ [EnhancedAI] initializeAI started');
    try {
      console.log('ğŸ”‘ [EnhancedAI] Checking for VITE_GEMINI_API_KEY...');
      const apiKey = import.meta.env.VITE_GEMINI_API_KEY;
      console.log('ğŸ”‘ [EnhancedAI] API Key exists:', !!apiKey);
      console.log('ğŸ”‘ [EnhancedAI] API Key length:', apiKey?.length || 0);
      
      if (!apiKey) {
        console.error('âŒ [EnhancedAI] No API key found in environment');
        throw new Error('Gemini API key not found');
      }

      console.log('ğŸ“¦ [EnhancedAI] Creating GoogleGenerativeAI instance...');
      this.genAI = new GoogleGenerativeAI(apiKey);
      console.log('âœ… [EnhancedAI] GoogleGenerativeAI instance created');
      
      console.log('ğŸ¤– [EnhancedAI] Getting generative model...');
      console.log('ğŸ“‹ [EnhancedAI] Number of function schemas:', FUNCTION_SCHEMAS.length);
      
      this.model = this.genAI.getGenerativeModel({
        model: "gemini-2.5-flash",
        systemInstruction: FUNCTION_CALLING_SYSTEM_PROMPT,
        tools: [{
          functionDeclarations: FUNCTION_SCHEMAS as any
        }],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.8,
          maxOutputTokens: 2048,
        },
      });
      console.log('âœ… [EnhancedAI] Generative model created');

      console.log('âœ… [EnhancedAI] Enhanced AI Service initialized successfully');
    } catch (error) {
      console.error('âŒ [EnhancedAI] Failed to initialize Enhanced AI Service:', error);
      console.error('âŒ [EnhancedAI] Error details:', error instanceof Error ? error.message : error);
      console.error('âŒ [EnhancedAI] Error stack:', error instanceof Error ? error.stack : 'No stack');
      throw error;
    }
  }

  async sendMessage(message: string): Promise<AIMessage> {
    console.log('ğŸš€ [EnhancedAI] sendMessage called with:', message);
    
    if (!this.model) {
      console.error('âŒ [EnhancedAI] Model not initialized');
      throw new Error('AI model not initialized');
    }

    try {
      console.log('ğŸ“ [EnhancedAI] Starting chat session...');
      // Start chat session
      const chat = this.model.startChat({
        history: []
      });
      console.log('âœ… [EnhancedAI] Chat session created');

      // Send message
      console.log('ğŸ“¤ [EnhancedAI] Sending message to AI...');
      const result = await chat.sendMessage(message);
      console.log('âœ… [EnhancedAI] Message sent, getting response...');
      
      const response = result.response;
      console.log('âœ… [EnhancedAI] Response received');
      console.log('ï¿½ [EnhancedAI] Raw response:', JSON.stringify(response, null, 2));

      // Check if response has function calls
      let functionCalls: any[] = [];
      try {
        functionCalls = response.functionCalls() || [];
        console.log('ï¿½ [EnhancedAI] Function calls:', functionCalls);
      } catch (e) {
        console.log('âš ï¸ [EnhancedAI] No function calls or error getting them:', e);
      }
      
      let functionResults: FunctionCallResult[] = [];
      let finalContent = '';

      if (functionCalls && functionCalls.length > 0) {
        console.log('ğŸ”§ [EnhancedAI] Function calls detected:', functionCalls.length, 'calls');
        
        // Execute function calls sequentially
        for (let i = 0; i < functionCalls.length; i++) {
          const functionCall = functionCalls[i];
          console.log(`ğŸ¯ [EnhancedAI] Executing function ${i + 1}/${functionCalls.length}:`, functionCall.name);
          
          try {
            const result = await this.executeFunctionCall(functionCall);
            console.log(`âœ… [EnhancedAI] Function ${functionCall.name} completed:`, result);
            functionResults.push(result);
          } catch (error) {
            console.error(`âŒ [EnhancedAI] Function ${functionCall.name} failed:`, error);
            functionResults.push({
              success: false,
              error: error instanceof Error ? error.message : 'Unknown error'
            });
          }
        }

        // Send function results back to model with timeout
        console.log('ğŸ“¤ [EnhancedAI] Sending function results back to AI...');
        const functionResponseParts = functionResults.map((result, index) => ({
          functionResponse: {
            name: functionCalls[index].name,
            response: result
          }
        }));
        console.log('ğŸ“¦ [EnhancedAI] Function response parts:', JSON.stringify(functionResponseParts, null, 2));

        try {
          console.log('â³ [EnhancedAI] Waiting for AI follow-up response (with 15s timeout)...');
          
          // Create a timeout promise
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('AI response timeout after 15 seconds')), 15000);
          });
          
          // Race between the actual response and timeout
          const followUpResult = await Promise.race([
            chat.sendMessage(functionResponseParts),
            timeoutPromise
          ]) as any;
          
          console.log('âœ… [EnhancedAI] Follow-up result received');
          
          const followUpResponse = followUpResult.response;
          console.log('âœ… [EnhancedAI] Follow-up response received');
          
          finalContent = followUpResponse.text();
          console.log('ğŸ“ [EnhancedAI] Final content from AI:', finalContent);
          
          // If AI returns empty content, generate manual response
          if (!finalContent || finalContent.trim() === '') {
            console.log('âš ï¸ [EnhancedAI] AI returned empty content, generating manual response');
            finalContent = this.generateResponseFromResults(functionResults, functionCalls);
          }
        } catch (timeoutError) {
          console.error('â±ï¸ [EnhancedAI] Timeout or error getting follow-up:', timeoutError);
          // Generate a manual response based on function results
          finalContent = this.generateResponseFromResults(functionResults, functionCalls);
          console.log('ğŸ“ [EnhancedAI] Generated manual response:', finalContent);
        }
      } else {
        console.log('ğŸ’¬ [EnhancedAI] No function calls, getting direct response');
        try {
          finalContent = response.text();
          console.log('ğŸ“ [EnhancedAI] Direct response:', finalContent);
        } catch (e) {
          console.error('âŒ [EnhancedAI] Error getting text from response:', e);
          finalContent = 'I received your message but had trouble generating a response. Please try again.';
        }
      }

      const aiMessage: AIMessage = {
        id: Date.now().toString(),
        content: finalContent,
        type: 'ai',
        timestamp: new Date(),
        functionCalls: functionCalls || [],
        functionResults
      };

      console.log('âœ… [EnhancedAI] AI message created:', aiMessage);
      return aiMessage;

    } catch (error) {
      console.error('âŒ [EnhancedAI] Error sending message:', error);
      console.error('âŒ [EnhancedAI] Error stack:', error instanceof Error ? error.stack : 'No stack trace');
      throw error;
    }
  }

  private generateResponseFromResults(results: FunctionCallResult[], calls: any[]): string {
    console.log('ğŸ”¨ [EnhancedAI] Generating manual response from results');
    
    let response = '';
    const successfulOps: string[] = [];
    const failedOps: string[] = [];

    results.forEach((result, index) => {
      const callName = calls[index]?.name || 'unknown';
      if (result.success) {
        successfulOps.push(result.message || callName);
      } else {
        failedOps.push(`${callName}: ${result.error}`);
      }
    });

    if (successfulOps.length > 0) {
      response += 'âœ… Successfully completed:\n' + successfulOps.map(op => `â€¢ ${op}`).join('\n');
    }

    if (failedOps.length > 0) {
      if (response) response += '\n\n';
      response += 'âŒ Failed operations:\n' + failedOps.map(op => `â€¢ ${op}`).join('\n');
    }

    if (!response) {
      response = 'I processed your request but couldn\'t generate a detailed response. Please check if the changes were applied.';
    }

    return response;
  }

  private async executeFunctionCall(functionCall: FunctionCall): Promise<FunctionCallResult> {
    console.log(`ğŸš€ [EnhancedAI] executeFunctionCall: ${functionCall.name}`);
    console.log(`ğŸ“‹ [EnhancedAI] Function call RAW object:`, functionCall);
    console.log(`ğŸ“‹ [EnhancedAI] Function call keys:`, Object.keys(functionCall));
    
    // Try to extract parameters from different possible properties
    let params = functionCall.parameters || functionCall.args || (functionCall as any).arguments || {};
    console.log(`ğŸ“‹ [EnhancedAI] Extracted parameters:`, params);
    console.log(`ğŸ“‹ [EnhancedAI] Parameters type:`, typeof params);
    console.log(`ğŸ“‹ [EnhancedAI] Parameters stringified:`, JSON.stringify(params));

    try {
      let result: FunctionCallResult;
      
      switch (functionCall.name) {
        case 'get_project_data':
          console.log('ğŸ“Š [EnhancedAI] Calling getProjectData...');
          result = await this.getProjectData();
          console.log('âœ… [EnhancedAI] getProjectData completed:', result);
          return result;
        
        case 'create_list':
          console.log('ğŸ“ [EnhancedAI] Calling createList with params:', params);
          result = await this.createList(params);
          console.log('âœ… [EnhancedAI] createList completed:', result);
          return result;
        
        case 'update_list':
          console.log('âœï¸ [EnhancedAI] Calling updateList...');
          result = await this.updateList(functionCall.parameters);
          console.log('âœ… [EnhancedAI] updateList completed:', result);
          return result;
        
        case 'delete_list':
          console.log('ğŸ—‘ï¸ [EnhancedAI] Calling deleteList...');
          result = await this.deleteList(functionCall.parameters);
          console.log('âœ… [EnhancedAI] deleteList completed:', result);
          return result;
        
        case 'create_task':
          console.log('ğŸ“ [EnhancedAI] Calling createTask...');
          result = await this.createTask(functionCall.parameters);
          console.log('âœ… [EnhancedAI] createTask completed:', result);
          return result;
        
        case 'update_task':
          console.log('âœï¸ [EnhancedAI] Calling updateTask...');
          result = await this.updateTask(functionCall.parameters);
          console.log('âœ… [EnhancedAI] updateTask completed:', result);
          return result;
        
        case 'delete_task':
          console.log('ğŸ—‘ï¸ [EnhancedAI] Calling deleteTask...');
          result = await this.deleteTask(functionCall.parameters);
          console.log('âœ… [EnhancedAI] deleteTask completed:', result);
          return result;
        
        case 'move_task':
          console.log('ğŸ”„ [EnhancedAI] Calling moveTask...');
          result = await this.moveTask(functionCall.parameters);
          console.log('âœ… [EnhancedAI] moveTask completed:', result);
          return result;
        
        default:
          console.error(`âŒ [EnhancedAI] Unknown function: ${functionCall.name}`);
          return {
            success: false,
            error: `Unknown function: ${functionCall.name}`
          };
      }
    } catch (error) {
      console.error(`âŒ [EnhancedAI] Error executing ${functionCall.name}:`, error);
      console.error(`âŒ [EnhancedAI] Error details:`, error instanceof Error ? error.message : error);
      console.error(`âŒ [EnhancedAI] Error stack:`, error instanceof Error ? error.stack : 'No stack');
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
  }

  private async getProjectData(): Promise<FunctionCallResult> {
    console.log(`ğŸ” [EnhancedAI] getProjectData started for project: ${this.projectUid}`);
    try {
      console.log('ğŸ“¡ [EnhancedAI] Calling apiService.getProject...');
      
      // Add timeout to API call
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('API timeout after 10 seconds')), 10000);
      });
      
      const apiPromise = apiService.getProject(this.projectUid);
      
      const response = await Promise.race([apiPromise, timeoutPromise]) as any;
      console.log('âœ… [EnhancedAI] API response received:', response);
      
      this.currentProjectData = response.data;
      console.log('ğŸ’¾ [EnhancedAI] Project data cached:', {
        name: response.data.name,
        lists: response.data.lists?.length || 0,
        totalTasks: response.data.lists?.reduce((sum, list) => sum + (list.tasks?.length || 0), 0) || 0
      });
      
      // Return simplified data structure to avoid issues
      const simplifiedData = {
        project_name: response.data.name,
        lists: response.data.lists?.map((list: any) => ({
          list_uid: list.list_uid,
          name: list.name,
          color: list.color,
          task_count: list.tasks?.length || 0,
          tasks: list.tasks?.map((task: any) => ({
            task_uid: task.task_uid,
            title: task.title,
            status: task.status,
            priority: task.priority
          })) || []
        })) || []
      };
      
      const result = {
        success: true,
        data: simplifiedData,
        message: `Project "${response.data.name}" has ${response.data.lists?.length || 0} lists`
      };
      console.log('âœ… [EnhancedAI] getProjectData returning:', result.message);
      return result;
    } catch (error) {
      console.error('âŒ [EnhancedAI] getProjectData failed:', error);
      console.error('âŒ [EnhancedAI] Error details:', error instanceof Error ? error.message : error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to get project data'
      };
    }
  }

  private async createList(params: any): Promise<FunctionCallResult> {
    console.log('ğŸ“ [EnhancedAI] createList called with params:', params);
    console.log('ğŸ“ [EnhancedAI] params type:', typeof params);
    console.log('ğŸ“ [EnhancedAI] params is null?', params === null);
    console.log('ğŸ“ [EnhancedAI] params is undefined?', params === undefined);
    
    try {
      // Validate params
      if (!params || typeof params !== 'object') {
        console.error('âŒ [EnhancedAI] Invalid params object:', params);
        return {
          success: false,
          error: 'Invalid parameters provided'
        };
      }

      if (!params.name) {
        console.error('âŒ [EnhancedAI] Missing list name');
        return {
          success: false,
          error: 'List name is required'
        };
      }

      // Get position - default to 0 if not specified
      let position = 0;
      
      if (params.position !== undefined && params.position !== null) {
        position = params.position;
        console.log('ğŸ“Š [EnhancedAI] Using provided position:', position);
      } else {
        // Try to get current project data to calculate position
        try {
          if (!this.currentProjectData) {
            console.log('ğŸ“¡ [EnhancedAI] Fetching project data for position calculation...');
            const projectResponse = await apiService.getProject(this.projectUid);
            this.currentProjectData = projectResponse.data;
          }
          position = this.currentProjectData?.lists?.length || 0;
          console.log('ğŸ“Š [EnhancedAI] Calculated position from project data:', position);
        } catch (err) {
          console.warn('âš ï¸ [EnhancedAI] Could not get project data for position, using 0:', err);
          position = 0;
        }
      }

      const listRequest: ListRequest = {
        project_uid: this.projectUid,
        name: params.name,
        color: params.color || '#3B82F6', // Default blue color
        position
      };

      console.log('ğŸ“¤ [EnhancedAI] Sending createList request:', listRequest);
      const response = await apiService.createList(listRequest);
      console.log('âœ… [EnhancedAI] List created successfully:', response.data);
      
      // Refresh project data
      await this.getProjectData();

      toast({
        title: "List Created",
        description: `Successfully created "${params.name}" list`,
      });

      return {
        success: true,
        data: response.data,
        message: `Created list "${params.name}"`
      };
    } catch (error) {
      console.error('âŒ [EnhancedAI] createList failed:', error);
      console.error('âŒ [EnhancedAI] Error stack:', error instanceof Error ? error.stack : 'No stack');
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to create list'
      };
    }
  }

  private async updateList(params: any): Promise<FunctionCallResult> {
    try {
      const updateData: any = {};
      if (params.name) updateData.name = params.name;
      if (params.color) updateData.color = params.color;
      if (params.position !== undefined) updateData.position = params.position;

      const response = await apiService.partialUpdateList(params.list_uid, updateData);
      
      // Refresh project data
      await this.getProjectData();

      toast({
        title: "List Updated",
        description: `Successfully updated the list`,
      });

      return {
        success: true,
        data: response.data,
        message: `Updated list successfully`
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to update list'
      };
    }
  }

  private async deleteList(params: any): Promise<FunctionCallResult> {
    try {
      await apiService.deleteList(params.list_uid);
      
      // Refresh project data
      await this.getProjectData();

      toast({
        title: "List Deleted",
        description: `Successfully deleted the list`,
      });

      return {
        success: true,
        message: `Deleted list successfully`
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to delete list'
      };
    }
  }

  private async createTask(params: any): Promise<FunctionCallResult> {
    try {
      const taskRequest: TaskRequest = {
        list_uid: params.list_uid,
        title: params.title,
        description: params.description || null,
        priority: params.priority || 'medium',
        status: params.status || 'todo',
        color: params.color || '#6B7280', // Default gray color
        position: params.position || null,
        is_completed: params.is_completed || false,
        due_date: params.due_date || null
      };

      const response = await apiService.createTask(taskRequest);
      
      // Refresh project data
      await this.getProjectData();

      toast({
        title: "Task Created",
        description: `Successfully created "${params.title}" task`,
      });

      return {
        success: true,
        data: response.data,
        message: `Created task "${params.title}"`
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to create task'
      };
    }
  }

  private async updateTask(params: any): Promise<FunctionCallResult> {
    try {
      const updateData: any = {};
      if (params.title) updateData.title = params.title;
      if (params.description !== undefined) updateData.description = params.description;
      if (params.priority) updateData.priority = params.priority;
      if (params.status) updateData.status = params.status;
      if (params.color) updateData.color = params.color;
      if (params.position !== undefined) updateData.position = params.position;
      if (params.is_completed !== undefined) updateData.is_completed = params.is_completed;
      if (params.due_date !== undefined) {
        updateData.due_date = params.due_date;
      }

      const response = await apiService.partialUpdateTask(params.task_uid, updateData);
      
      // Refresh project data
      await this.getProjectData();

      toast({
        title: "Task Updated",
        description: `Successfully updated the task`,
      });

      return {
        success: true,
        data: response.data,
        message: `Updated task successfully`
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to update task'
      };
    }
  }

  private async deleteTask(params: any): Promise<FunctionCallResult> {
    try {
      await apiService.deleteTask(params.task_uid);
      
      // Refresh project data
      await this.getProjectData();

      toast({
        title: "Task Deleted",
        description: `Successfully deleted the task`,
      });

      return {
        success: true,
        message: `Deleted task successfully`
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to delete task'
      };
    }
  }

  private async moveTask(params: any): Promise<FunctionCallResult> {
    try {
      await apiService.moveTask(params.task_uid, params.target_list_uid);
      
      // Refresh project data
      await this.getProjectData();

      toast({
        title: "Task Moved",
        description: `Successfully moved the task`,
      });

      return {
        success: true,
        message: `Moved task to target list successfully`
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to move task'
      };
    }
  }

  // Get current project data without making API call
  getCurrentProjectData(): ProjectWithLists | null {
    return this.currentProjectData;
  }
}